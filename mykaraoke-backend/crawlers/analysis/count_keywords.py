import json
from fuzzywuzzy import fuzz

filename = "dataset_indeed-scraper_2023-09-16_01-10-37-409"

with open(
    f"keywords_extracted/{filename}.json",
    "r",
    encoding="utf-8",
) as json_file:
    data = json.load(json_file)

keyword_map = {}

for keyword_list in data:
    for keyword in keyword_list:
        keyword = keyword.lower()
        if keyword in keyword_map:
            keyword_map[keyword] += 1
        else:
            keyword_map[keyword] = 1

one_to_many_map = {
    "html/css": ["html", "css"],
    "spring boot": ["spring", "spring boot"],
    "c/c++": ["c", "c++"],
}

similarity_map = {
    "front-end": "frontend",
    "reactjs": "react",
    "css3": "css",
    "html5": "html",
    "angularjs": "angular",
    "angular.js": "angular",
    "react.js": "react",
    "node": "node.js",
    "nodejs": "node.js",
    "node js": "node.js",
    "continuous integration": "ci/cd",
    "continuous deployment": "ci/cd",
    "user experience": "ui/ux",
    "ux": "ui/ux",
    "user experiences": "ui/ux",
    "ui design": "ui/ux",
    "ux design": "ui/ux",
    "golang": "go",
    "oop": "object-oriented programming",
    "object oriented programming": "object-oriented programming",
    "object-oriented design": "object-oriented programming",
    "amazon web services": "aws",
    "google cloud": "gcp",
    "google cloud platform": "gcp",
    "front-end technologies": "frontend",
    "front-end development": "frontend",
    "frontend development": "frontend",
    "back-end": "backend",
    "back-end development": "backend",
    "backend development": "backend",
    "back end": "backend",
    "front end": "frontend",
    "frontend engineer": "frontend",
    "full-stack": "fullstack",
    "full stack": "fullstack",
    "visual design": "design",
    "ci/cd tools": "ci/cd",
    "tests": "testing",
    "agile software development": "agile",
    "agile methodologies": "agile",
    "agile environment": "agile",
    "agile development": "agile",
    "tdd": "test-driven development",
    "test driven development": "test-driven development",
    "artificial intelligence": "ai",
    "quality assurance": "qa",
    "quality": "qa",
    "maintain": "maintenance",
    "nosql databases": "nosql",
    "sql databases": "sql",
    "sql queries": "sql",
    "nextjs": "next.js",
    "rest apis": "rest",
    "rest api": "rest",
    "mobile development": "mobile",
    "mobile applications": "mobile",
    "designing": "design",
    "test": "testing",
    "deployments": "deployment",
    "problem solving skills": "troubleshooting",
    "bug fixes": "troubleshooting",
    "problem-solving skills": "troubleshooting",
    "problem solving": "troubleshooting",
    "complex problems": "troubleshooting",
    "problem solver": "troubleshooting",
    "troubleshoot": "troubleshooting",
    "maintaining": "maintenance",
    "prototypes": "prototyping",
    "apis": "api",
    "test cases": "testing",
    "vue.js": "vue",
    "vuejs": "vue",
    "web application": "web application development",
    "web app": "web application development",
    "web developer": "web application development",
    "responsive web design": "responsive design",
    "problem": "responsive design",
    "verbal communication skills": "communication",
    "communication skills": "communication",
    "collaboration skills": "collaboration",
    "collaborate": "collaboration",
    "reusable code": "reusability",
    "data visualization": "visualization",
    "architecting": "architecture",
    "technical architecture": "architecture",
    "microservice architecture": "microservices",
    "maintainable code": "maintainability",
    "ci/cd pipielines": "ci/cd",
    "postgres": "postgresql",
    "mentoring": "mentorship",
    "backend services": "backend",
    "ci/cd pipelines": "ci/cd",
}


for from_keyword, to_keyword in similarity_map.items():
    if from_keyword in keyword_map:
        if to_keyword in keyword_map:
            keyword_map[to_keyword] += keyword_map[from_keyword]
        else:
            keyword_map[to_keyword] = keyword_map[from_keyword]
        del keyword_map[from_keyword]

for from_keyword, to_keywords in one_to_many_map.items():
    if from_keyword in keyword_map:
        for to_keyword in to_keywords:
            if to_keyword in keyword_map:
                keyword_map[to_keyword] += keyword_map[from_keyword]
            else:
                keyword_map[to_keyword] = keyword_map[from_keyword]
        del keyword_map[from_keyword]

categories_map = {
    "JavaScript": "language",
    "React.js": "framework",
    "CSS": "language",
    "HTML": "language",
    "design": "skill",
    "Python": "language",
    "troubleshooting": "skill",
    "TypeScript": "language",
    "Java": "language",
    "Node.js": "runtime",
    "design": "skill",
    "testing": "skill",
    "frontend": "specialization",
    "UI/UX": "specialization",
    "AWS": "cloud",
    "Angular": "framework",
    "SQL": "language",
    "MySQL": "database",
    "CI/CD": "practice",
    "agile": "practice",
    "backend": "specialization",
    "machine learning": "specialization",
    "scalability": "principle",
    "DevOps": "specialization",
    "Bootstrap": "ui",
    "clean code": "principle",
    "innovation": "trait",
    "relational databases": "database",
    "PHP": "language",
    "interpersonal skills": "skill",
    "mobile": "platform",
    "Android": "platform",
    "iOS": "platform",
    "responsive design": "principle",
    "Ruby": "language",
    "mentoring": "skill",
    "collaboration skills": "skill",
    "time management": "skill",
    "Swift": "language",
    "Windows": "platform",
    "EC2": "cloud",
    "flexibility": "trait",
    "Postman": "tool",
    "Salesforce": "crm",
    "Kotlin": "language",
    "SVN": "version",
    "Ansible": "devops",
    "J2EE": "specification",
    "Visual Studio": "ide",
    "Spring": "framework",
    "BitBucket": "version",
    "Hibernate": "framework",
    "Spring Boot": "framework",
    "ECS": "cloud",
    "planning": "skill",
    "performance optimization": "principle",
    "technical leadership": "skill",
    "gRPC": "framework",
    "Photoshop": "tool",
    "system design": "specialization",
    "infrastructure": "specialization",
    "visualization": "skill",
    "Perl": "language",
    "reusability": "principle",
    "positive attitude": "trait",
    "detail-oriented": "trait",
    "maintainability": "principle",
    "network security": "specialization",
    "Selenium": "framework",
    "C": "language",
    "C++": "language",
    "self-starter": "trait",
    "hardware": "specialization",
    "SASS": "language",
    "SQL Server": "database",
    "usability": "principle",
    "prototyping": "process",
    "scrum": "practice",
    "Django": "framework",
    "jQuery": "framework",
    "NoSQL": "database",
    "React Native": "framework",
    "PostgreSQL": "database",
    "REST": "architecture",
    "microservices": "architecture",
    "Docker": "devops",
    "Kubernetes": "devops",
    "Vue.js": "framework",
    "MongoDB": "database",
    "Terraform": "devops",
    "Oracle": "cloud",
    "Redis": "database",
    "accessibility": "principle",
    ".NET": "framework",
    "distributed systems": "topic",
    "data structures": "topic",
    "design patterns": "topic",
    "documentation": "process",
    "code reviews": "process",
    "Jira": "tool",
    "Azure": "cloud",
    "problem-solving": "skill",
    "Go": "language",
    "Redux": "framework",
    "XML": "language",
    "performance": "principle",
    "GraphQL": "language",
    "Linux": "platform",
    "reliability": "trait",
    "attention to detail": "trait",
    "monitoring": "process",
    "project management": "process",
    "mentorship": "trait",
    "Webpack": "tool",
    "Maven": "tool",
    "Entity Framework": "framework",
    "organizational skills": "skill",
    "Git": "version",
    "GCP": "cloud",
    "C#": "language",
    "AI": "specialization",
    "ASP.NET": "framework",
    "Hadoop": "tool",
    "Figma": "tool",
    "SOA": "architecture",
    "Grafana": "tool",
    "Cassandra": "database",
    "Saml": "language",
    "Flask": "framework",
    "MVC": "architecture",
    "wireframes": "process",
    "functionality": "principle",
    "Jest": "framework",
    "integration testing": "process",
    "marketing": "process",
    "HTTP": "architecture",
    "Ruby on Rails": "framework",
    "SOAP": "architecture",
    "documentation": "process",
    "analytical skills": "skill",
    "time-management": "skill",
    "management": "skill",
    "QA": "specialty",
    "Kafka": "tool",
    "Next.js": "framework",
}

format_map = {
    "react": "React.js",
    "javascript": "JavaScript",
    "css": "CSS",
    "html": "HTML",
    "python": "Python",
    "typescript": "TypeScript",
    "java": "Java",
    "node.js": "Node.js",
    "ui/ux": "UI/UX",
    "aws": "AWS",
    "angular": "Angular",
    "sql": "SQL",
    "mysql": "MySQL",
    "ci/cd": "CI/CD",
    "devops": "DevOps",
    "bootstrap": "Bootstrap",
    "php": "PHP",
    "android": "Android",
    "ios": "iOS",
    "ruby": "Ruby",
    "swift": "Swift",
    "windows": "Windows",
    "ec2": "EC2 (AWS)",
    "postman": "Postman",
    "salesforce": "Salesforce",
    "kotlin": "Kotlin",
    "svn": "SVN",
    "ansible": "Ansible",
    "j2ee": "J2EE",
    "visual studio": "Visual Studio",
    "spring": "Spring",
    "bitbucket": "BitBucket",
    "hibernate": "Hibernate",
    "spring boot": "Spring Boot",
    "ecs": "ECS (AWS)",
    "grpc": "gRPC",
    "photoshop": "Photoshop",
    "perl": "Perl",
    "selenium": "Selenium",
    "c": "C",
    "c++": "C++",
    "sass": "SASS",
    "sql server": "SQL Server",
    "scrum": "Scrum",
    "django": "Django",
    "jquery": "jQuery",
    "nosql": "NoSQL",
    "react native": "React Native",
    "postgresql": "PostgreSQL",
    "rest": "REST",
    "docker": "Docker",
    "kubernetes": "Kubernetes",
    "vue": "Vue.js",
    "mongodb": "MongoDB",
    "terraform": "Terraform",
    "oracle": "Oracle",
    "redis": "Redis",
    ".net": ".NET",
    "jira": "Jira",
    "azure": "Azure",
    "go": "Go",
    "redux": "Redux",
    "xml": "XML",
    "graphql": "GraphQL",
    "linux": "Linux",
    "webpack": "Webpack",
    "maven": "Maven",
    "entity framework": "Entity Framework",
    "git": "Git",
    "gcp": "GCP",
    "c#": "C#",
    "ai": "AI",
    "asp.net": "ASP.NET",
    "hadoop": "Hadoop",
    "figma": "Figma",
    "soa": "SOA",
    "grafana": "Grafana",
    "cassandra": "Cassandra",
    "spring framework": "spring",
    "saml": "SAML",
    "flask": "Flask",
    "mvc": "MVC",
    "jest": "Jest",
    "ruby on rails": "Ruby on Rails",
    "soap": "SOAP",
    "qa": "QA",
    "http": "HTTP",
    "kafka": "Kafka",
    "next.js": "Next.js",
}

for from_format, to_format in format_map.items():
    if from_format in keyword_map:
        keyword_map[to_format] = keyword_map[from_format]
        del keyword_map[from_format]


sorted_items = sorted(keyword_map.items(), key=lambda x: x[1], reverse=False)

# print(sorted_items)

# with open(f"keywords_counted/{filename}.json", "w", encoding="utf-8") as file:
#     json.dump(sorted_items, file, indent=4)

filter_out_words = [
    "computer science",
    "benefits",
    "software engineer",
    "equity",
    "equal opportunity employer",
    "diversity",
    "religion",
    "race",
    "technology",
    "sexual orientation",
    "engineers",
    "age",
    "product managers",
    "national origin",
    "color",
    "compensation",
    "implementation",
    "dental",
    "ca",
    "experience",
    "bachelor's degree",
    "tools",
    "parental leave",
    "paid time off",
    "code",
    "tools",
    "marital status",
    "medical",
    "gender identity",
    "sex",
    "technologies",
    "disability",
    "web technologies",
    "veteran status",
    "coding",
    "vision",
    "features",
    "scalable",
    "base salary",
    "vision insurance",
    "san francisco",
    "california",
    "culture",
    "new features",
    "compensation package",
    "building",
    "disability insurance",
    "san jose",
    "investors",
    "dental coverage",
    "growth",
    "skills",
    "determination",
    "salary range",
    "equal opportunity",
    "ancestry",
    "snacks",
    "benefits package",
    "expression",
    "paid holidays",
    "bonus",
    "flexible time off",
    "offices",
    "holidays",
    "citizenship",
    "gender expression",
    "competitive compensation",
    "retirement plan",
    "business",
    "medical coverage",
    "accommodations",
    "tuition reimbursement",
    "bachelor's degree",
    "equal employment opportunity",
    "bugs",
    "vision coverage",
    "employee assistance program",
    "platforms",
    "flexible spending account",
    "genetic information",
    "projects",
    "401(k)",
    "401k",
    "full-time",
    "software engineers",
    "impact",
    "customers",
    "qualifications",
    "feedback",
    "industry trends",
    "base pay",
    "reasonable accommodations",
    "salary",
    "pay range",
    "pregnancy",
    "competitive salary",
    "resume",
    "pto",
    "metrics",
    "medical benefits",
    "continuous improvement",
    "stock options",
    "protected veteran status",
    "implement",
    "health insurance",
    "disability status",
    "remote",
    "libraries",
    "solutions",
    "production",
    "gender",
    "remote work",
    "senior software engineer" "support",
    "location",
    "inclusion",
    "services",
    "build",
    "engineering team",
    "platform",
    "industry experience",
    "tooling",
    "funding",
    "develop",
    "developers",
    "team player",
    "healthcare",
    "discrimination",
    "applications",
    "united states",
    "travel",
    "dental insurance",
    "life insurance",
    "senior software engineer",
    "medical insurance",
    "bachelor's degree",
    "commuter benefits",
]

filtered_words = [
    item for item in sorted_items if item[1] > 9 and item[0] not in filter_out_words
]

category_list = []
for keyword_tuple in filtered_words:
    if keyword_tuple[0] in categories_map:
        category_list.append(
            (
                keyword_tuple[0],
                keyword_tuple[1],
                categories_map[keyword_tuple[0]],
            )
        )
    else:
        category_list.append(keyword_tuple)


print(category_list)

# count_strings = ["responsive design", "rwd", "responsive web design"]
# for count_string in count_strings:
#     if count_string in keyword_map:
#         print(f"{count_string}: {keyword_map[count_string]}")
#     else:
#         print(f"{count_string}: 0")

for item in category_list:
    if fuzz.ratio(item[0], "next") > 30:
        print(item)
